#! /usr/bin/env perl

###########################################################################
##
## PDB番号再振り直しプログラム					Last Update 2012/07/29
##	PDB内の原子順序番号や残基番号を振り直します
##
##  $ prenum <モード> <入力ファイル> [出力ファイル] [--start 開始値] [--clear]
##  
##  モード
##		-A, --atom        原子順序番号を振り直す
##		-R, --residue     残基番号を振り直す(最新法)
##		-R1, --residue1   残基番号を振り直す(従来法)
##		-R2, --residue2   残基番号を振り直す(最新法)
##      
##		* 従来法は，残基番号が4桁を超えた場合，残基番号を **** で書き換えます．
##		  一方，最新法は，上記状況において，残基番号を0からリセットされた値で書き換えます．
##
##	別のオプション
##		-S, --start 開始値
##		-C, --clear 残基番号が後ろの領域を使っていた場合削除する(moltools 対策)
##
###########################################################################

use strict;
use File::Temp;

my $mode = 0;
my $in = "";
my $out = "";
my $start = 1;
my $option = 0;
my $flag = 0;
foreach(@ARGV){
	if((/^--help$/i) || (/^-H$/i)){	# ヘルプ
		$mode = 0;
		last;
	}
	elsif((/^--atom$/i) || (/^-A$/i)){	# 原子順序番号
		$mode = 1;
	}
	elsif((/^--residue$/i) || (/^-R$/i) || (/^--residue2$/i) || (/^-R$/i)){	# 残基番号(最新法; デフォルト)
		$mode = 2;
	}
	elsif((/^--residue1$/i) || (/^-R1$/i)){	# 残基番号
		$mode = 3;
	}
	elsif((/^--clear$/i) || (/^-C$/i)){	# 残基番号が後ろの領域を使っていた場合削除する
		$option = 1;
	}
	elsif((/^--start$/i) || (/^-S$/i)){	# 開始値
		$flag = 1;
	}
	elsif($flag == 1){	# 開始値
		if(/^-?\d+$/){
			$start = $_;
		}
		else{
			print " ERROR: Start number must be integer";
			exit;
		}
	}
	else{
		if($in eq ""){	# 入力ファイル
			$in = $_;
		}
		else{			# 出力ファイル
			$out = $_;
		}
	}
}

if($mode == 0){	# ヘルプ(あるいは未定義オプションを指定した場合)
	&help;
}
else{
	&check_file($in);
	
	my $tmp = File::Temp->new(TEMPLATE => '.prenum-XXXXXX');
	$SIG{'TERM'} = $SIG{'PIPE'} = $SIG{'HUP'} = $SIG{'INT'} = sub {
		unlink $tmp;
		exit;
	};	# プログラムが中断した場合の処理
	
	if($mode == 1){		# 原子順序番号
		&atomorder($in, $tmp, $start);
	}
	elsif($mode == 2){		# 残基番号(最新法; デフォルト)
		&residueorder($in, $tmp, $start, 2, $option);
	}
	elsif($mode == 3){		# 残基番号(従来法)
		&residueorder($in, $tmp, $start, 1, $option);
	}
	&overwrite($in, $out, $tmp);
}
exit;

# =============== atomorder =============== #
# 原子順序番号リセット
sub atomorder{
my $in = shift(@_);	# 入力ファイル
my $out = shift(@_);	# 出力ファイル
my $start = shift(@_);	# 開始値

my $num = $start - 1;

open(IN, "$in");
open(OUT, "> $out");
while(<IN>){
	if((/^HETATM/i) || (/^ATOM/i)){
		$num ++;
		my $atomnum = "";
		if($num >= 100000){	# 原子順序番号が10000を超えたら，*に変換
			$atomnum = "*****";
		}
		else{	# 通常の原子順序番号
			$atomnum = $num;
		}
		my $line = &adjust(5, $atomnum);
		substr($_, 6, 5) = $line;
		print OUT;
	}
	elsif(/^TER/i){
		print OUT "TER\n";
	}
	elsif(/^CONECT/i){
		print OUT;
	}
}
close(IN);
print OUT "END\n";
close(OUT);
}

# =============== residueorder =============== #
# 残基番号リセット
sub residueorder{
my $in = shift(@_);		# 入力ファイル
my $out = shift(@_);		# 出力ファイル
my $start = shift(@_);		# 開始値
my $flag = shift(@_);		# 残基オーバーの挙動
my $option = shift(@_);	# 残基番号の 4 桁目が後ろに伸びていた場合

my $num = $start - 1;
my $contain = 0;	# 残基を構成する原子数(1-3個で構成されていたら Warning を出す)

my $beforeres = "";		# 前の残基名
open(IN, "$in");
open(OUT, "> $out");
while(<IN>){
	if((/^HETATM/i) || (/^ATOM/i)){
		my $line = $_;
		my $nowres = substr($line, 17, 12);
		my $amino_flag = &rec_amino($nowres);
		my $nowatom = substr($line, 12, 4);
		if(($beforeres ne $nowres) || (($amino_flag == 1) && ($nowatom eq " N  "))){	# 前の残基と異なる場合，あるいはアミノ酸で atomtype が N の時に処理
			if(($contain <= 2) && (($beforeres !~ /^((HOH)|(SOL)|(WAT))/) && ($beforeres !~ /^$/))){	# 最初と水分子を除き，数原子で残基を作っているものを警告
				print " WARNING: Residue number changed with a few atoms\n";
				print "    Current residue number: $num\n";
				print "    Residue name: \"$beforeres\"\n\n";
			}
			$num ++;
			$beforeres = $nowres;
			$contain = 0;
		}
		
		my $resnum = "";
		if($num >= 10000){	# 残基番号が10000を超えたら，*に変換(従来法)
			if($flag == 1){
				$resnum = "****";
			}
			elsif($flag == 2){	# 残基番号をリセットする
				$resnum = 0;
				$num = 0;
			}
		}
		else{	# 通常の残基番号
			$resnum = $num;
		}
		
		my $strnum = &adjust(4, $resnum);
		my $check = substr($line, 20, 6);
		if($check =~ /^[\s\D]{2}\s*\d+$/){	# 通常の場合
			substr($line, 22, 4) = $strnum;
		}
		else{	# 残基番号がユニットの部分まで進出していた場合削除する
			substr($line, 20, 6) = "  $strnum";
		}
		
		if($option == 1){	# 残基番号が後ろの領域を使っていた場合削除する
			substr($line, 26, 4) = "    ";
		}
		
		print OUT $line;
		$contain ++;
	}
	elsif(/^TER/i){
		print OUT "TER\n";
		$beforeres = "TER";
	}
	elsif(/^CONECT/i){
		print OUT;
	}
}
close(IN);
print OUT "END\n";
close(OUT);
}

# =============== adjust =============== #
sub adjust{
my $max = shift(@_);	# 調整後文字数
my $line = shift(@_);	# 文字列

my $space = length($line);	# 文字列の長さ
$space = $max - $space;		# 追加するスペース数
$space = " " x $space;			# スペース
$line = $space . $line;		# スペース追加
return($line);
}

# =============== overwrite =============== #
## 上書き確認
sub overwrite{
my $in = shift(@_);
my $out = shift(@_);
my $tmp = shift(@_);

if($out =~ /^$/){
	print " INFORMATION: 出力先が指定されていません．\n";
	print " INFORMATION: 上書き(O)，別名で保存(S)，何もしない(C)\n > ";
	my $user = <STDIN>;
	$user =~ s/\n//;
	if($user =~ /^O$/i){
		unlink $in;
		rename $tmp, $in;
	}
	elsif($user =~ /^S$/i){
		print " ファイル名: ";
		$user = <STDIN>;
		$user =~ s/\n//;
		rename $tmp, $user;
	}
	else{
		unlink $tmp;
		exit;
	}
}
else{
	rename $tmp, $out;
}
}

# =============== rec_amino =============== #
# アミノ酸残基かを判定
sub rec_amino{
my $res = shift(@_);

my $flag = 0;
if($res =~ /(ALA)|(ARG)|(ASN)|(ASP)|(CYS)|(GLN)|(GLU)|(GLY)|(HIS)|(HIE)|(HID)|(HIP)|(ILE)|(LEU)|(LYS)|(MET)|(PRO)|(SER)|(THR)|(TRP)|(TYR)|(VAL)/i){
	$flag = 1;
}

return $flag;
}

# =============== check_file =============== #
# ファイルチェック
sub check_file{
my $file = shift(@_);

if(! -f $file){
	print " ERROR: No such file: $file\n";
	exit;
}

return $file;
}

# --------------- help --------------- #
sub help{
print << "HELP";
 Re-numbering atom or residue order program for PDB
  \$ prenum <MODE> <INPUT> [OUTPUT] [--start INIT_NUMBER] [--clear]
  
  MODE
      -A, --atom        Re-numbering atom order
      -R, --residue     Re-numbering residue order(Newer method)
      -R1, --residue1   Re-numbering residue order(conventional method)
      -R2, --residue2   Re-numbering residue order(Newer method)
      
      * When digit number of residue order is over 4,
        residue order is overwritten with "****" at conventional method.
        Newer method is that residue order is overwritten with 
        new number reset from 0 at above situation.

  OTHER OPTION
      -S, --start       Start with specified number
      -C, --clear       When residue number is displayed at 24-30 column,
                        correct to 23-26 (for moltools bug)

HELP
}
